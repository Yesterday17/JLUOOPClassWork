//
// Created by Yesterday17 on 5/13.
//

#include <iostream>
#include "../menu/Menu.h"
#include "1/A.h"
#include "1/B.h"

Menu *week11 = new Menu(u8"面向对象程序设计上机练习（六）", std::vector<MenuItem>{
    {
        u8"阅读并执行代码,然后回答问题",
        []() {
          std::cout << "1. 去掉 virtual 后 B 的析构函数不会被执行，只执行了 A 的析构函数（由于*p的类型为A）。" << std::endl;
          std::cout << "2. 不可以，override 的类型必须和基类匹配。" << std::endl;
          std::cout << "3. 匹配的是(3)的初始值，说明初始值是静态绑定的。" << std::endl;
          std::cout << "4. 不可以，改为 private 后继承类B中就无法使用该属性了。" << std::endl;
          std::cout << "5. 没有。" << std::endl;
          std::cout << "6. (9)的作用是给静态成员变量赋初始值。" << std::endl;
          std::cout << "7. 不可以，抽象类含有纯虚函数，无法实例化。" << std::endl;
          std::cout << "8. 若仅删去virtual，无法通过编译（由于=0）；若同时删除=0，无法通过编译（由于函数体不存在）；如果加上函数体，编译成功，且调用时调用A中的Func2。" << std::endl;
          std::cout << "9. 在A中不存在Func3；仍然不可以。" << std::endl;
          std::cout << "10. (15)尝试向参数列表为[]的函数传入一个参数。" << std::endl;

          std::cout << std::endl << "以下为原始执行结果：" << std::endl;
          WEEK11_1::A *p = new WEEK11_1::B;
          //---------------------------------------------(10)

          p->Func2(50);
          //---------------------------------------------(11)

          p->Func2();
          //---------------------------------------------(12)

          p->Func1();
          //---------------------------------------------(13)

          // p->Func3(100);
          //---------------------------------------------(14)

          // p->Func1(100);
          //---------------------------------------------(15)
          delete p;
          return 0;
        }
    }
});
